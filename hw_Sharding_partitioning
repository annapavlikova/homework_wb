Задание 1.

Создайте 3 таблицы: users и items, ratings
Cозданы в sql-файле.

Обоснуйте выбор типов данных при создании таблиц.
Для таблицы users:
user_id SERIAL PRIMARY KEY, (так как не id не должен повторяться) 
birth_date DATE, (так как здесь удобен тип дата) 
sex VARCHAR(3), (подразумевала, что будет либо 'v', либо 'm', 3 знака взяла про запас) 
age INT (возраст - целое число)

Для таблицы orders: 
item_id SERIAL PRIMARY KEY, 
price FLOAT(10) (может быть нецелым, хотя потом я заполняла целыми) 
buyer INT (это user_id) 
decription TEXT (текстовое поле) 
category TEXT

Для таблицы ratings: 
item_id INT 
user_id INT 
review TEXT (текстовое поле) 
rating INT (подразумеваю число от 0 до 5)

Подумайте, как связать таблицы. Добавьте дополнительные столбцы в таблицы, если сочтете это необходимым.
Таблицы users и orders я предлагаю свяязать через новый столбец в orders под названием buyer - так мы сможем определить, кто оформил каждый заказ. Таблицы orders и ratings связаны через item_id. Таблицы users и ratings связаны через user_id.

Добавьте несколько значений (~20) в каждую таблицу. Попробуйте сгенерировать значения для наполнения таблиц (а не прописывать их каждый раз вручную)
Добавила, есть в sql-файле.


Задание 2.
Какой тип связи/отношения между таблицами users и ratings? Между таблицами  items, ratings?

Тип связи users и ratings: один ко многим (так как один пользователь мог написать несколько отзывов, соответственно в таблице ratings будет несколько строк для этого пользователя)

Тип связи items и ratings: один ко многим (так как кадому отзыву соответствует только один товар, но каждому товару может соответствовать несколько отзывов)


Задание 3.
К какой/каким из созданных таблиц вы бы предложили создать индекс? Объясните, почему.
Я думаю, в таблице users целесообразно сделать индекс для столбца user_id (поэтому я прописала для него тип SERIAL PRIMARY KEY), чтобы можно было быстрее находить информацию по идентифекатору пользователя, а не просматривать все данные таблицы.
Аналогично можно индексировать orders по столбцу item_id (тоже обозначила его SERIAL PRIMARY KEY)


Задание 4.
Отметьте те команды, которые смогут добавить записи в таблицу. Объясните, почему.

INSERT INTO Car VALUES ('7984672834', 'E340BT, 77, Lada Granta',
 'Kрасный', 87, 2017, 35)
не добавит записи в таблицу, так как после 'E340BT нет закрывающей кавычки, поэтому запись 'E340BT, 77, Lada Granta' воспринимается как одна строка, а дальше должно идти INT, но идёт строка.

INSERT INTO Car_owner VALUES ('7984672834', 'Иван Петров')
Да, добавит, так как типы данных и синтаксис верные

INSERT INTO Car_owner VALUES ('7984672834', 'Татьяна Иванова')
Нет, не добавит, так как INN повторяется с уже существующей в этой таблице строкой, а при создании таблицы INN обозначался как PRIMARY KEY.

INSERT INTO Car Owner VALUES ('4752909757', 'Mван Петров')
Нет, не добавит, так как неправильное название таблицы

INSERT INTO Car VALUES ('6239572784', 'E340BT, 77, 'Volkswagen Polo',
 'Синий', 105, 2018, 40)
Нет, не добавит, так как ошибка в количестве кавычек: 'E340BT, 77, 'Volkswagen Polo', и Volkswagen Polo не читается как строка

INSERT INTO Car VALUES ('4752909757', 'A822EY', 99, 'Skoda Rapid',
 'черный', 125, 2021, 35)
 Нет, не добавит, так как в таблице Car_owner нет строки с INN '4752909757' (он не добавился ранее)
 
INSERT INTO Car VALUES ('7984672834', 'A822EY', 99, 'Hyundai Solaris',
 'черный', 123, 2019, 20)
Да, добавит, так как типы данных и синтаксис верные

INSERT INTO Car VALUES ('74478679847', '8971HP, 199, 'Kia Sportage',
 'бeлый', 18, 2017, 35)
Нет, не добавит, так как ошибка в количестве кавычек: '8971HP, 199, 'Kia Sportage', и 'Kia Sportage' не читается как строка

INSERT INTO Car VALUES ('7984672834', 'E340BT, 77, 'Toyota RAV4',
 'Серебристо-серый, 146, 2019)
Нет, не добавит, так как ошибка в количестве кавычек

INSERT INTO Car VALUES ('7984672834', 'H454EE', 98, 'Skoda Rapid',
 'чeрный', 45, 2021, 0)
Нет, не добавит, так как уже есть запись с таким ключом, а он не должен повторяться

Задание 5.
Можно ли использовать данный скрипт для шардинга таблицы на 32 документа?  И генерацией из этой таблицы 16 тестовых таблиц примерно по 2 документа test.docs00, 01, 02, ..., 15

INSERT INTO docs00
SELECT * FROM documents WHERE (id%16)=0

...

INSERT INTO docs15
SELECT * FROM documents WHERE (id%16)=15

Я думаю, этот код разделит таблицу на 16 тестовых. То есть мы разделим данные на отдельные части, и каждую из них можно будет вынести на отдельный сервер, то есть шардинг удастся по идее)
